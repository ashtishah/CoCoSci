function [sequences, states, deltas, alphas] =...
    generateSeqsHMM(alphabet, maxMotifLength, seqLength, numSeqs, paramRange)

%% generate motifs

motifs = generateMotifs(alphabet, maxMotifLength);

% get dimensions of each entry in motifs
motifSizes = cell2mat(cellfun(@(x) size(x), motifs, 'UniformOutput', false)');

% number of states (multiply dimensions along columns and sum)
numStates = sum(prod(motifSizes, 2));


%% set parameters for sequence generation sequences with different parameter settings
% (delta = staying in motif, alpha = prior over motifs);

% give extremal dispersion of parameters
if paramRange
    deltas = rand(1,numSeqs); alphas = rand(1, numSeqs);
    
    % two gaussians 
    deltas = [0.1+0.2*randn(1, numSeqs/2) (0.2*randn(1, numSeqs/2) + 0.9)];
    % remove values below and aove
    dist = [0.1+0.2*randn(1, numSeqs) (0.2*randn(1, numSeqs) + 0.9)]
else
    deltas = rand(1,numSeqs); alphas = rand(1, numSeqs);
end

% compute denominator for C (sum over number of motifs times alpha^length)
denom = arrayfun(@(x, y) x .* alphas.^y,...
    motifSizes(:,2).', 1:length(motifs), 'UniformOutput', false);

% (1-deltas)/ 
% (3 .* alpha.^1 + 6 * alpha.^2 + ... + numOfMaxLengthMotifs * alpha^maxMotifLength)
C = (1-deltas) ./ sum(cell2mat(denom'), 1);

% emissions are deterministic
emissions = eye(numStates);

% preallocate sequence and state storage
if length(seqLength) > 1
    sequences = cell(numSeqs*length(seqLength), 1);
    states = cell(numSeqs*length(seqLength), 1);
else
    sequences = nan(numSeqs, seqLength);
    states = nan(numSeqs, seqLength);

end


for seq = 1:numSeqs
    %% generate transition matrix
 
    transitionMat = generateTransitionMat(...
    motifs, motifSizes, numStates, maxMotifLength, alphas(seq), deltas(seq), C(seq));
    
    %% generate sequences
       
    % delta to C*alpha
    prior = [C(seq).*alphas(seq), transitionMat(1,2:end)];
    
     % randomly sample one state between 1 and numStates with probabilities specified by prior
    startAt = randsample(numStates, 1, true, prior);

    % generate sequences
    
    if length(seqLength) > 1
       
        for i = 1:length(seqLength)
        [sequences{(seq-1)*length(seqLength) + i}, states{(seq-1)*length(seqLength) + i}] =...
            hmmgenerate2(seqLength(i), transitionMat, emissions, startAt,...
            'Symbols', cell2mat(cellfun(@(x) reshape(x.', 1, []), motifs, 'UniformOutput', false)));
        end
        
    else
        
        [sequences(seq,:), states(seq,:)] =...
            hmmgenerate2(seqLength, transitionMat, emissions, startAt,...
            'Symbols', cell2mat(cellfun(@(x) reshape(x.', 1, []), motifs, 'UniformOutput', false)));
    end
end

if ischar(alphabet)
    sequences = char(sequences);
end

%csvwrite('states.csv', states)
csvwrite('Experiment/sequences.csv', sequences)
%csvwrite('deltas.csv', deltas)
%csvwrite('alphas.csv', alphas)

end